# 기타 요소
## 아키텍처
![UML-아키텍처](https://user-images.githubusercontent.com/29668913/187192733-8cbb3754-99fc-4ebb-9a96-c622525ada1f.jpg)
## 각 구성 요소의 사용 이유
### 안드로이드 + 코틀린
안드로이드의 경우 xml방식이 아닌 compose 라이브러리를 사용해 ui를 구현했는데, 이는 xml 방식보다 declarative한 compose 방식이 더 생산성이 높기 때문임. 또한 기존부터 안드로이드를 해 왔던 사람과 다르게, 안드로이드를 처음 접하는 입장으로써는 xml방식이 아니라 compose를 선택함에 따라 생기는 추가적인 러닝 커브가 거의 없을 거라고 판단하였음

ui로 웹이 아닌 어플리케이션을 선택한 이유는 사용자 입장에서 독서대와 어플리케이션을 하나의 연동된 프로그램으로 더욱 받아들이기 쉽게 하기 위해서임. 만약 별도의 웹사이트를 통해 접속해야 했으면 사용자 입장에서 완전히 별개의 서비스라고 인식할 여지가 있기 때문
### 스프링 + 자바
우선 기존에 가장 친숙했던 언어가 자바였기 때문에, 가장 많은 시간이 소요될 것이라고 예상된 api서버를 자바와 스프링의 조합으로 작성하였음. 또한 핵심이 되는 api 서버 작성을 위해서는 자바의 안정적인 ecosystem이 중요하다고 생각했기 때문임
프로젝트 초기에 코틀린 + 스프링으로 작성을 시도하였으나, 추가적인 학습 소요가 지나치게 많이 들어간다고 판단되었기 때문에 곧바로 자바로 전환하였음
### nodejs + 타입스크립트
스프링에서도 웹소켓을 지원하지만, 이를 nodejs에서 구현한 이유는 자바(타입)스크립트의 구동방식 때문임. 웹소켓은 기존의 HTTP 통신과는 다르게 작은 크기의 메시지가 빠른 주기로 왔다갔다 하기 때문에 이는 하나의 스레드와 이벤트 큐를 사용하는 자바스크립트에 유리하다고 생각되었음

타입스크립트는 타입이 존재하지 않는 자바스크립트에 타입을 통해 안정성을 더해준다 판단하여 사용하였음.

웹소켓을 사용한 이유는 서버 측에서 어플리케이션으로 신호(공부 신호나 다른 학습자 입장 신호 등)를 보내야 하기 때문. 웹소켓 말고 Long Polling과 같은 방식이 있지만, 웹소켓을 사용할 수 있는 안드로이드에서는 굳이 사용할 필요가 없다 판단하였음. 웹소켓 구현에는 [ws](https://github.com/websockets/ws)라는 라이브러리를 사용했음

### 라즈베리 파이 + 아두이노
단순한 센서나 버튼에 관한 처리에 대해서는 아두이노에서 담당하고, 좀 더 복잡한 로직이 필요한 경우는 라즈베리파이에서 담당하는 것이 좋다고 판단하였기 때문. 특히 라즈베리파이에서는 파이썬을 이용해 생산성을 우선하였음. 이 두 장비가 가장 친숙했던 것도 선택의 근거가 되었음

### OpenCV
딴짓 감지 로직을 위한 영상처리 라이브러리로, 현재 영상처리에서 가장 대중적인 OpenCV를 사용하였음. 딥러닝과 같은 인공지능도 고려하였으나 학습에 필요한 데이터가 절대적으로 부족하였기 때문에 영상처리를 이용한 알고리즘을 만들기로 했음. OpenCV또한 파이썬을 이용해 최대한 빠른 시간 내로 개발할 수 있도록 하였음. 어처피 core 연산은 C++로 된 라이브러리로 동작하니, 퍼포먼스 손실은 크지 않다고 판단했기 때문

### nginx
이 프로젝트에서는 [nginx](https://github.com/veryneuron/study_mate_project/blob/server_dev/server/default.conf)를 리버스 프록시로 사용하였음. 이유는 api서버와 웹소켓 서버가 별개로 동작하는 상황에서, 이를 외부에서는 포트를 통해 서비스를 구분하는 것이 아닌 url을 통해 구분하는 것이 직관적이라 판단하였기 때문임. 또한 리버스 프록시를 사용함으로써 얻는 또다른 이점은 https 인증을 하나의 지점에서만 해도 된다는 것임. 외부 통신에 사용되는 nginx 서버에만 https 통신을 하고, 내부적으로는 http 프로토콜을 사용함(웹소켓 또한 handshaking에는 http를 사용함)

https 인증은 self-signed certificate를 사용했는데, 이는 별도의 dns 비용을 지불하고 싶지 않았기 때문임. 하지만 설정이 지나치게 복잡해지고 보안에 매우 취약하다는 문제점이 있어 이후에는 사용하지 않을 예정

### 도커
각 서버를 도커 이미지로 만들고, [docker compose](https://github.com/veryneuron/study_mate_project/blob/server_dev/server/docker-compose.yml)를 통해 여러 이미지를 통합했는데 이는 여러 개의 독립적인 프로그램이 동작하는 이 프로젝트에서, 다른 환경에 배포할 시 최대한 동일한 환경을 유지하고자 했기 때문임. 실제로 docker hub를 이용해 push와 docker-compose up만으로 배포 작업이 가능해져 매우 편리했음

### AWS
이 프로젝트에서는 EC2 서비스와 IoT Core서비스를 사용하였음. 우선 EC2의 경우 다른 대체제인 BeanStalk나 lightSail을 고려했으나, Beanstalk의 경우 하나의 서버당 하나의 어플리케이션 배포에 최적화되어 있고, lightSail도 마찬가지임. 이런 작은 프로젝트에서 굳이 여러 서버를 추가할 필요성을 느끼지 못해 최대한 하나의 서버 안에서 모든 서비스를 배포할 방법을 찾았고, 가장 기본적인 가상머신 대여인 EC2를 사용하게 되었음

IoT Core의 경우 처음에는 사용을 고려하지 않았음. iot에 최적화되어 있는 mqtt 통신을 사용하기로 했는데, mqtt 통신을 위해서는 브로커 서버가 필요함. 처음에는 이 브로커 서버에 rabbitMQ에 mqtt 확장기능을 추가해서 사용했음. 하지만 AWS에서 제공하는 Iot Core을 사용하면 별도의 브로커 서버를 사용할 필요가 없어져, 아키텍처의 복잡성이 줄어들기 때문에 rabbitMQ에서 AWS IoT Core로의 전환을 결정함

[관련 이슈](https://github.com/veryneuron/study_mate_project/issues/8)

### On-Premise?
여기서 opencv 클라이언트 프로그램의 경우 AWS상이 아닌 On-Premise에 존재하는데, 이는 비용 때문임. 초기에는 opencv를 라즈베리파이에 직접 탑재해서 가동했으나, 영상처리 딜레이가 거의 6초 가까이 나와 사용이 불가능하다고 판단하고 라즈베리파이는 영상 전송만 하고 연산은 별도의 고성능 pc에서 하기로 결정함. 하지만 AWS에서 무료로 제공하는 가상 머신은 대부분 컴퓨팅 파워가 좋지 않았고, 고성능의 머신을 대여하기 위해서는 많은 비용이 들었음. 그 때문에 AWS lambda도 고려했으나, 이는 최대 연결 한도가 15분밖에 되지 않아 지속적으로 학습자의 상황을 영상처리로 모니터링해야 하는 이 프로젝트에는 맞지 않았음. 따라서 가지고 있는 pc를 그대로 활용해서 프로그램을 가동하도록 결정함

## ERD
![UML-ERD](https://user-images.githubusercontent.com/29668913/187197600-3c180a11-b4ab-43a2-ac74-163452db5373.jpg)

연관관계는 User 테이블과 Study_time이 1:N 관계이고, 다시 Study_time과 Study_record가 1:N 관계임. 이는 학습자 한 명에 있어 여러 개의 공부 시간이 존재하고, 다시 이 하나의 공부 시간 안에 여러 개의 집중 시간이 존재하기 때문임. 공부 시간이란 사용자가 의도한 공부시간, 즉 버튼을 눌러 시작하고 다시 눌러 종료하는 그 사이의 시간이고, 집중 시간은 그 사이에 딴짓 감지 로직에 의해 자동으로 측정되는 사용자의 집중 시간임. 학습자가 한 번의 공부시간 동안 집중을 했다 안 했다를 여러 번 할 수 있기 때문에 1:N 관계임

각 row에는 timestamp가 저장되어 있음. 학습 여부는 이 timestamp의 값을 통해 판단하고, 학습 시간은 요청이 들어오면 그때 계산함. 이를 rich domain model을 사용해 구현하였음. [참고](https://github.com/veryneuron/study_mate_project/blob/main/doc/%EA%B3%B5%EB%B6%80%20%EC%8B%9C%EC%9E%91%2C%20%EC%A2%85%EB%A3%8C%20%2B%20%EB%94%B4%EC%A7%93%20%EA%B2%BD%EB%B3%B4.md#%EC%8A%A4%ED%94%84%EB%A7%81-api%EC%84%9C%EB%B2%84)

데이터베이스로 PostgreSQL을 사용한 이유는 자바와 마찬가지로 가장 익숙했던 RDB였기 때문. 보통은 MySQL과 같은 DB를 사용하지만 이 프로젝트에서는 크게 차이가 난다고 생각되지는 않아 친숙한 PostgreSQL을 사용함

측정값 저장에는 NoSQL인 MongoDB를 사용했음. 이는 우선 json방식의 MongoDB는 RDB보다 쓰기 속도에서 우위를 가지고 있기 때문에, 짧은 시간에 여러 변에 쓰기 요청이 발생하는 측정값 저장의 특성상 이는 NoSQL에 적합하다 판단했기 때문임. 또한 테이블 간의 관계가 존재하는 것이 아닌 상대적으로 비정형적인 측정치인 것도 NoSQL을 사용하는 근거가 되었음

## 아두이노
아두이노에는 온습도 센서인 DHT11, LED, 스위치가 핀으로 꽂혀있음
우선 DHT11 온습도 센서는 (+와 5V), (OUT과 A0), (-와 GND)로 연결함
LED는 (+와 GND), (-와 3번핀) 로 연결함
스위치는 (GND와 GND), (VCC와 2번핀) 로 
